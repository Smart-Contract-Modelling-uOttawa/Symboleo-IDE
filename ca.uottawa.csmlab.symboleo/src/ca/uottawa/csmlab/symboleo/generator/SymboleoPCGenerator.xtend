///*
// * generated by Xtext 2.25.0
// */
package ca.uottawa.csmlab.symboleo.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import ca.uottawa.csmlab.symboleo.symboleo.DomainType
import ca.uottawa.csmlab.symboleo.symboleo.RegularType
import ca.uottawa.csmlab.symboleo.symboleo.Attribute
import java.util.List
import ca.uottawa.csmlab.symboleo.symboleo.Model
import java.util.ArrayList
import ca.uottawa.csmlab.symboleo.symboleo.Enumeration
import ca.uottawa.csmlab.symboleo.symboleo.Parameter
import ca.uottawa.csmlab.symboleo.symboleo.VariableRef
import ca.uottawa.csmlab.symboleo.symboleo.Ref
import ca.uottawa.csmlab.symboleo.symboleo.VariableDotExpression
import ca.uottawa.csmlab.symboleo.symboleo.Expression
import ca.uottawa.csmlab.symboleo.symboleo.And
import ca.uottawa.csmlab.symboleo.symboleo.Or
import ca.uottawa.csmlab.symboleo.symboleo.Equality
import ca.uottawa.csmlab.symboleo.symboleo.Comparison
import ca.uottawa.csmlab.symboleo.symboleo.Plus
import ca.uottawa.csmlab.symboleo.symboleo.Minus
import ca.uottawa.csmlab.symboleo.symboleo.Div
import ca.uottawa.csmlab.symboleo.symboleo.Multi
import ca.uottawa.csmlab.symboleo.symboleo.PrimaryExpressionFunctionCall
import ca.uottawa.csmlab.symboleo.symboleo.NegatedPrimaryExpression
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionTrue
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionFalse
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionDouble
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionInt
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionEnum
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionString
import ca.uottawa.csmlab.symboleo.symboleo.AtomicExpressionParameter
import ca.uottawa.csmlab.symboleo.symboleo.PrimaryExpressionRecursive
import ca.uottawa.csmlab.symboleo.symboleo.TwoArgMathFunction
import ca.uottawa.csmlab.symboleo.symboleo.OneArgMathFunction
import ca.uottawa.csmlab.symboleo.symboleo.TwoArgStringFunction
import ca.uottawa.csmlab.symboleo.symboleo.OneArgStringFunction
import ca.uottawa.csmlab.symboleo.symboleo.Obligation
import ca.uottawa.csmlab.symboleo.symboleo.Power
import ca.uottawa.csmlab.symboleo.symboleo.Variable
import ca.uottawa.csmlab.symboleo.symboleo.Proposition
import ca.uottawa.csmlab.symboleo.symboleo.POr
import ca.uottawa.csmlab.symboleo.symboleo.PAnd
import ca.uottawa.csmlab.symboleo.symboleo.PEquality
import ca.uottawa.csmlab.symboleo.symboleo.NegatedPAtom
import ca.uottawa.csmlab.symboleo.symboleo.PAtomPredicate
import ca.uottawa.csmlab.symboleo.symboleo.PAtomEnum
import ca.uottawa.csmlab.symboleo.symboleo.PAtomRecursive
import ca.uottawa.csmlab.symboleo.symboleo.PComparison
import ca.uottawa.csmlab.symboleo.symboleo.PAtomVariable
import ca.uottawa.csmlab.symboleo.symboleo.PAtomPredicateTrueLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PAtomPredicateFalseLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PAtomIntLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PAtomStringLiteral
import java.util.Map
import java.util.HashMap
import ca.uottawa.csmlab.symboleo.symboleo.PAtomDoubleLiteral
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunction
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionHappens
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionHappensBefore
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionHappensAfter
import ca.uottawa.csmlab.symboleo.symboleo.PredicateFunctionHappensWithin
import ca.uottawa.csmlab.symboleo.symboleo.Event
import ca.uottawa.csmlab.symboleo.symboleo.VariableEvent
import ca.uottawa.csmlab.symboleo.symboleo.PowerEvent
import ca.uottawa.csmlab.symboleo.symboleo.ObligationEvent
import ca.uottawa.csmlab.symboleo.symboleo.ContractEvent
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationSuspended
import ca.uottawa.csmlab.symboleo.symboleo.PFContractTerminated
import ca.uottawa.csmlab.symboleo.symboleo.PFContractSuspended
import ca.uottawa.csmlab.symboleo.symboleo.PFContractResumed
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationTerminated
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationResumed
import ca.uottawa.csmlab.symboleo.symboleo.PFObligationDischarged
import ca.uottawa.csmlab.symboleo.symboleo.impl.RegularTypeImpl
import ca.uottawa.csmlab.symboleo.symboleo.AssignVariable
import ca.uottawa.csmlab.symboleo.symboleo.AssignExpression
import ca.uottawa.csmlab.symboleo.symboleo.PowerFunction

//
/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SymboleoPCGenerator {
	enum propositionType{
		TRIGGER, ANTECEDENT, CONSEQUENT
	}
	enum normType{
		OBLIGATION, POWER
	}
	
	val assets = new ArrayList<RegularType>
	val events = new ArrayList<RegularType>
	val roles = new ArrayList<RegularType>
	val roleInstances = new HashMap<String, Pair<String, String>>
	val enumerations = new ArrayList<Enumeration>
	val parameters = new ArrayList<Parameter>
	val obligations = new ArrayList<Obligation>
	val powers = new ArrayList<Power>
	val constraints = new ArrayList<Proposition>
	
	val eventVariables = new ArrayList<Variable>
	val roleVariables = new ArrayList<Variable>
		
	val obligationTriggerEvents = new HashMap<Obligation, List<PAtomPredicate>>
	val survivingObligationTriggerEvents = new HashMap<Obligation, List<PAtomPredicate>>
	val powerTriggerEvents = new HashMap<Power, List<PAtomPredicate>>
	
	val obligationAntecedentEvents = new HashMap<Obligation, List<PAtomPredicate>>
	val obligationConsequentEvents = new HashMap<Obligation, List<PAtomPredicate>>
	val powerAntecedentEvents = new HashMap<Power, List<PAtomPredicate>>
	
//	val obligationFullfilmentEvents = new HashMap<Obligation, List<PAtomPredicate>>
//	val survivingObligationFullfilmentEvents = new HashMap<Obligation, List<PAtomPredicate>>
	
	val pcVariables = new ArrayList<Pair<String,String>>
	val pcSituations = new ArrayList<String>
	val pcRoles = new ArrayList<String>
	val pcAssets = new ArrayList<String>
	val pcDomEvents = new ArrayList<String>
	val pcEnumerations = new ArrayList<String>
	val pcParameters =  new ArrayList<String>
	
	def void parse (Model model) {
		parameters.addAll(model.parameters)
		
		// extract assets, events, roles and enumerations
		for (domainType : model.domainTypes) {
			if (domainType instanceof RegularType) {
				var RegularType base = getBaseType(domainType)
				if (base !== null) {
					switch base.ontologyType.name {
						case 'Asset': assets.add(domainType as RegularType)
						case 'Event': events.add(domainType as RegularType)
						case 'Role': roles.add(domainType as RegularType)
					}
				}
			} else if (domainType instanceof Enumeration) {
				enumerations.add(domainType as Enumeration)
			}
		}
		
		// extract contract parameters and exclude roles
		//var Integer rand = 1
		for (param : parameters) {		
			if (param.type.domainType instanceof RegularTypeImpl) {
				var DomainType domainType = param.type.domainType
				var RegularType base = getBaseType(domainType)
				if (base !== null) {
					if (base.ontologyType.name == 'Role') {
				//		roleInstances.put(param.name, new Pair(base.name, 'party' + rand))
				//		rand ++
					}
					else {
						pcParameters.add(param.name)
					}
				}
			}
			else{
				pcParameters.add(param.name)
			}
		}

		// extract obligations, antecedents, consequents and triggers
		for (obligation: model.obligations){
			obligations.add(obligation)
			
			val proposition = obligation.antecedent
			obligationAntecedentEvents.put(obligation, collectPropositionEvents(proposition))
			
			val proposition2 = obligation.consequent
			obligationConsequentEvents.put(obligation, collectPropositionEvents(proposition2))
			
			if (obligation.trigger !== null){
				val proposition3 = obligation.trigger
				obligationTriggerEvents.put(obligation, collectPropositionEvents(proposition3))
			}
			
			//val proposition4 = obligation.trigger
			//obligationFullfilmentEvents.put(obligation, collectPropositionEvents(proposition4))
		}
		
		// extract powers, antecedents and triggers
		for (power: model.powers){
			powers.add(power)
			
			val proposition = power.antecedent
			powerAntecedentEvents.put(power, collectPropositionEvents(proposition))
			
			if (power.trigger !== null){
				val proposition2 = power.trigger
				powerTriggerEvents.put(power, collectPropositionEvents(proposition2))				
			}
		}
		
		// extract event and role variables
		for(variable: model.variables){
			if (events.indexOf(variable.type) != -1){
				eventVariables.add(variable)
			}
			
			if (roles.indexOf(variable.type) != -1){
				roleVariables.add(variable)
			}
		}
		
		for (obligation: model.survivingObligations){
			if (obligation.trigger !== null){
				val proposition = obligation.trigger
				survivingObligationTriggerEvents.put(obligation, collectPropositionEvents(proposition))				
			}
			
			//val proposition = obligation.trigger
			//survivingObligationFullfilmentEvents.put(obligation, collectPropositionEvents(proposition))
		}
		
		for (constr : model.constraints) {
			constraints.add(constr)
		}
	}
	
	def void compileTriggers(Model model){
		
	}	
	
	def void addVariable (String name, String startProposition, String variableClass, String attributes) {	
		
		var parameters = startProposition
		if(attributes != null) {
			parameters += attributes
		}
			
		switch(variableClass) {
			case 'Event': {
				val p = new Pair(name, name + " : Event(" + parameters + ");");
				pcVariables.add(p)
			}
			case 'Role': {
				val p = new Pair(name, name + " : Role(" + parameters + ");");
				pcVariables.add(p)
			}
			default : {
				val p = new Pair(name, name + " :" + variableClass + "(" + parameters + ");");
				pcVariables.add(p)
				}
		}
	}
	
	def String generatePowerProposition (String powerName, String exertedEventName) {
		return "(" + powerName + "._active & " + exertedEventName + "._happened & " + 
				exertedEventName + ".performer = " + powerName +"_creditor._name & " +
				 powerName + "_creditor._is_performer )"
	}
	
	def void addSituation (String name, String proposition) {
		pcSituations.add(name + " : Situation (" + proposition + ");")
	}
	
	def String generateProposition (String normName, normType ntype, propositionType ptype, String exertedEventName) {
		switch ptype {
			case ANTECEDENT: {
				val situatonName = normName + "_antecedent"
				addSituation(situatonName, exertedEventName + ".event._happened")
				return situatonName + ".state = holds"	 
				}
			case TRIGGER: {
				val situatonName = normName + "_triggered"
				addSituation(situatonName, exertedEventName + ".event._happened")
				return situatonName + ".state = holds"	 
				}
			case CONSEQUENT:
				switch(ntype){
					case OBLIGATION: {
						val situatonName = normName + "_consequent"
						addSituation(situatonName, exertedEventName + ".event._happened & " + 
								exertedEventName + ".performer = " + normName +"_debtor._name & " +
								normName + "_debtor._is_performer")
						return situatonName + ".state = holds"	 
						}
				 	case POWER: {
				 		val situatonName = normName + "_consequent"
						addSituation(situatonName, exertedEventName + ".event._happened & " + 
						exertedEventName + ".performer = " + normName +"_creditor._name & " +
						normName + "_creditor._is_performer")
						return situatonName + ".state = holds"
				 		}
				 }
		}
	}
	
	def String generateContractTerminationSituation (Model model) {
		var isFirst = true
		var cntTermPowers = new String("")
			
		for(power: model.powers) {
			if(power.consequent instanceof PFContractTerminated) {
				val eventName = power.name + "_exertion"			
				addVariable(eventName, power.name + ".state=inEffect", "Event", null)
				
				if(isFirst) {
					cntTermPowers += generatePowerProposition(power.name, eventName)
					isFirst = false;
				}
				else
					cntTermPowers += '|' + generatePowerProposition(power.name, eventName)						
			}
		}				
		
		if(cntTermPowers.length > 0) {
			var situationName = model.contractName + "_termination"
			addSituation(situationName, cntTermPowers)
			return situationName + ".state=holds"
		}
		return "FALSE"
	}
	
	def String generateContractSuspensionSituation (Model model) {
		var isFirst = true
		var cntSusPowers = new String("")
			
		for(power: model.powers) {
			if(power.consequent instanceof PFContractSuspended) {
				val eventName = "suspended_" + model.contractName			
				addVariable(eventName, power.name + ".state=inEffect", "Event", null)
				
				if(isFirst) {
					cntSusPowers += generatePowerProposition(power.name, eventName)
					isFirst = false;
				}
				else
					cntSusPowers += '|' + generatePowerProposition(power.name, eventName)						
			}
		}				
		
		if(cntSusPowers.length > 0) {
			var situationName = model.contractName + "_suspension"
			addSituation(situationName, cntSusPowers)
			return situationName + ".state=holds"
		}
		return "FALSE";
	}
	
	def String generateContractResumptionSituation (Model model) {
		var isFirst = true
		var cntResPowers = new String("")
			
		for(power: model.powers) {
			if(power.consequent instanceof PFContractResumed) {
				val eventName = "resumption_" + model.contractName			
				addVariable(eventName, power.name + ".state=inEffect", "Event", null)
				
				if(isFirst) {
					cntResPowers += generatePowerProposition(power.name, eventName)
					isFirst = false;
				}
				else
					cntResPowers += '|' + generatePowerProposition(power.name, eventName)						
			}
		}				
		
		if(cntResPowers.length > 0) {
			var situationName = model.contractName + "_resumption"
			addSituation(situationName, cntResPowers)
			return situationName + ".state=holds"
		}
		return "FALSE"
	}

	def Map<String, String> generateObligationsSuspensionSituation (Model model) {
		var Map<String, String> propositions = new HashMap<String, String>()
		var Map<String, String> situations = new HashMap<String, String>()
			
		for(power: model.powers) {
			if(power.consequent instanceof PowerFunction) {
				var cons = power.consequent
				if(cons instanceof PFObligationSuspended) {
					var oblName = cons.norm.name
					var eventName = power.name + "_exerted"
					addVariable(eventName, power.name + ".state=inEffect", "Event", null)
					addSituation(power.name + "_exertion", generatePowerProposition(power.name, eventName))
					
					if(situations.get(oblName)== null) {					
						propositions.put(oblName, generatePowerProposition(power.name, eventName))
					}
					else
						propositions.put(oblName, propositions.get(oblName) + '|' + generatePowerProposition(power.name, eventName))						
				}			
			}
		}			
		
		for(Map.Entry<String, String> entry : propositions.entrySet()) {
			if(entry.value.length > 0) {
				var situationName = entry.getKey() + "_suspension"
				addSituation(situationName, entry.getValue())
				situations.put(entry.getKey(), situationName + ".state=holds")			
			}
		}
		
		return situations
	}
	
	def Map<String, String> generateObligationsResumptionSituation (Model model) {
		var Map<String, String> propositions = new HashMap<String, String>()
		var Map<String, String> situations = new HashMap<String, String>()
			
		for(power: model.powers) {
			if(power.consequent instanceof PowerFunction) {
				var cons = power.consequent
				if(cons instanceof PFObligationResumed) {
					var oblName = cons.norm.name
					var eventName = "resumption_" + oblName
					addVariable(eventName, power.name + ".state=inEffect", "Event", null)
					
					if(situations.get(oblName) == null) {					
						propositions.put(oblName, generatePowerProposition(power.name, eventName))
					}
					else
						propositions.put(oblName, propositions.get(oblName) + '|' + generatePowerProposition(power.name, eventName))						
				}			
			}
		}			
		
		for(Map.Entry<String, String> entry : propositions.entrySet()) {
			if(entry.value.length > 0) {
				var situationName = entry.getKey() + "_resumption"
				addSituation(situationName, entry.getValue())
				situations.put(entry.getKey(), situationName + ".state=holds")			
			}
		}
		
		return situations
	}
	
	def Map<String, String> generateObligationsDischargeSituation (Model model) {
		var Map<String, String> propositions = new HashMap<String, String>()
		var Map<String, String> situations = new HashMap<String, String>()
			
		for(power: model.powers) {
			if(power.consequent instanceof PowerFunction) {
				var cons = power.consequent
				if(cons instanceof PFObligationDischarged) {
					var oblName = cons.norm.name
					var eventName = "discharged_" + oblName
					addVariable(eventName, power.name + ".state=inEffect", "Event", null)
					
					if(situations.get(oblName) == null) {					
						propositions.put(oblName, generatePowerProposition(power.name, eventName))
					}
					else
						propositions.put(oblName, propositions.get(oblName) + '|' + generatePowerProposition(power.name, eventName))						
				}						
			}
		}			
		
		for(Map.Entry<String, String> entry : propositions.entrySet()) {
			if(entry.value.length > 0) {
				var situationName = entry.getKey() + "_discard"
				addSituation(situationName, entry.getValue())
				situations.put(entry.getKey(), situationName + ".state=holds")			
			}
		}
		
		return situations
	}
	
	def Map<String, String> generateObligationsTerminationSituation (Model model) {
		var Map<String, String> propositions = new HashMap<String, String>()
		var Map<String, String> situations = new HashMap<String, String>()
			
		for(power: model.powers) {
			if(power.consequent instanceof PowerFunction) {
				var cons = power.consequent
				if(cons instanceof PFObligationTerminated) {
					var oblName = cons.norm.name
					var eventName = "termination_" + oblName
					addVariable(eventName, power.name + ".state=inEffect", "Event", null)
					
					if(situations.get(oblName) == null) {					
						propositions.put(oblName, generatePowerProposition(power.name, eventName))
					}
					else
						propositions.put(oblName, propositions.get(oblName) + '|' + generatePowerProposition(power.name, eventName))
				}
			}
		}			
		
		for(Map.Entry<String, String> entry : propositions.entrySet()) {
			if(entry.value.length > 0) {
				var situationName = entry.getKey() + "_termination"
				addSituation(situationName, entry.getValue())
				situations.put(entry.getKey(), situationName + ".state=holds")			
			}
		}
		
		return situations
	}
	
	def Map<String, String> generateObligationViolatedSituation (Model model) {
		var Map<String, String> violations = new HashMap<String, String>()
			
		for(obligation: model.obligations) {
			var  consEvents = obligationConsequentEvents.get(obligation)
			if(consEvents !== null)
				for(e : consEvents) {
					var ev = getEvent(e.predicateFunction)
					var situationName = obligation.name + "_violated"
					addSituation(situationName, ev + ".event._expired | ("+ ev + ".event._happened & !(" + ev + ".event.performer = " + obligation.name + "_debtor._name & " + obligation.name + "_debtor._is_performer))")
					violations.put(obligation.name, situationName + ".state = holds")
				}
		}		
		
		return violations
	}
	
	def Map<String, String> generateObligationExpiredSituation (Model model) {
		var Map<String, String> expirations = new HashMap<String, String>()
			
		for(obligation: model.obligations) {
			var  antEvents = obligationAntecedentEvents.get(obligation)
			if(antEvents !== null)
				for(e : antEvents) {
					var ev = getEvent(e.predicateFunction)
					var situationName = obligation.name + "_expired"
					addSituation(situationName, ev + ".event._expired | ("+ ev + ".event._happened & !(" + ev + ".event.performer = " + obligation.name + "_debtor._name & " + obligation.name + "_debtor._is_performer))")
					expirations.put(obligation.name, situationName + ".state = holds")
				}
		}		
		
		return expirations
	}
	
	def Map<String, String> generatePowerExpiredSituation (Model model) {
		var Map<String, String> expirations = new HashMap<String, String>()
			
		for(power: model.powers) {
			var  antEvents = powerAntecedentEvents.get(power)
			if(antEvents !== null)
				for(e : antEvents) {
					var ev = getEvent(e.predicateFunction)
					var situationName = power.name + "_expired"
					addSituation(situationName, ev + ".event._expired | ("+ ev + ".event._happened & !(" + ev + ".event.performer = " + power.name + "_debtor._name & " + power.name + "_debtor._is_performer))")
					expirations.put(power.name, situationName + ".state = holds")
				}
		}		
		
		return expirations
	}
	
	def Map<String, String> generatePowerExertedSituation (Model model) {
		var Map<String, String> exertion = new HashMap<String, String>()
			
		for(power: model.powers) {
			var situationName = power.name + "_exertion.state=holds"
			exertion.put(power.name, situationName)
		}		
		
		return exertion
	}
	
	def Map<String, String> generateAntecedentsSituation (Model model) {
		var Map<String, String> situations = new HashMap<String, String>()
			
		for(obligation: model.obligations) {
			val antecedent = generatePropositionString(obligation.name, normType.OBLIGATION, propositionType.ANTECEDENT, obligation.antecedent)
			situations.put(obligation.name, antecedent)
		}
		
		for(power: model.powers) {
			val antecedent = generatePropositionString(power.name, normType.POWER, propositionType.ANTECEDENT, power.antecedent)
			situations.put(power.name, antecedent)
		}
		
		return situations
	}
	
	def Map<String, String> generateConsequentsSituation (Model model) {
		var Map<String, String> situations = new HashMap<String, String>()
			
		for(obligation: model.obligations) {
			val consequent = generatePropositionString(obligation.name, normType.OBLIGATION, propositionType.CONSEQUENT, obligation.consequent)
			situations.put(obligation.name, consequent)
		}
		
		return situations
	}
	
	def Map<String, String> generateTriggersSituation (Model model) {
		var Map<String, String> situations = new HashMap<String, String>()
			
		for(obligation: model.obligations) {
			val trigger = generatePropositionString(obligation.name, normType.OBLIGATION, propositionType.TRIGGER, obligation.trigger)
			situations.put(obligation.name, trigger)
		}
		
		for(power: model.powers) {
			val trigger = generatePropositionString(power.name, normType.POWER, propositionType.TRIGGER, power.trigger)
			situations.put(power.name, trigger)
		}
		
		return situations
	}
	
	
/*	def Map<String, String> generatePowersSuspensionSituation (Model model) {
		var Map<String, String> propositions = new HashMap<String, String>()
		var Map<String, String> situations = new HashMap<String, String>()
			
 		for(power: model.powers) {
			if(power.consequent instanceof PFPowerSuspended) {
				//var oblName = power.consequent.norm		get an error!
				var powName = "delivery"
				var eventName = "suspension_" + powName
				addEvent(eventName, power.name + ".state=inEffect", null, null)
				
				if(situations.get(powName) == null) {					
					propositions.put(powName, generatePowerProposition(power.name, eventName))
				}
				else
					propositions.put(powName, propositions.get(powName) + '|' + generatePowerProposition(power.name, eventName))						
			}
		}			
		
		for(Map.Entry<String, String> entry : propositions.entrySet()) {
			if(entry.value.length > 0) {
				var situationName = entry.getKey() + "_suspension"
				addSituation(situationName, entry.getValue())
				situations.put(entry.getKey(), situationName + ".state=holds")			
			}
		}
		
		return situations
	}*/
	
	/*def Map<String, String> generatePowersResumptionSituation (Model model) {
		var Map<String, String> propositions = new HashMap<String, String>()
		var Map<String, String> situations = new HashMap<String, String>()
			
		for(power: model.powers) {
			if(power.consequent instanceof PFPowerResumed) {
				//var oblName = power.consequent.norm		get an error!
				var powName = "delivery"
				var eventName = "resumption_" + powName
				addEvent(eventName, power.name + ".state=inEffect")
				
				if(situations.get(powName) == null) {					
					propositions.put(powName, generatePowerProposition(power.name, eventName))
				}
				else
					propositions.put(powName, propositions.get(powName) + '|' + generatePowerProposition(power.name, eventName))						
			}
		}			
		
		for(Map.Entry<String, String> entry : propositions.entrySet()) {
			if(entry.value.length > 0) {
				var situationName = entry.getKey() + "_resumption"
				addSituation(situationName, entry.getValue())
				situations.put(entry.getKey(), situationName + ".state=holds")			
			}
		}
		
		return situations
	}
	
	def Map<String, String> generatePowerwTerminationSituation (Model model) {
		var Map<String, String> propositions = new HashMap<String, String>()
		var Map<String, String> situations = new HashMap<String, String>()
			
		for(power: model.powers) {
			if(power.consequent instanceof PFPowerTerminated) {
				//var oblName = power.consequent.norm		get an error!
				var powName = "delivery"
				var eventName = "termination_" + powName
				addEvent(eventName, power.name + ".state=inEffect")
				
				if(situations.get(powName) == null) {					
					propositions.put(powName, generatePowerProposition(power.name, eventName))
				}
				else
					propositions.put(powName, propositions.get(powName) + '|' + generatePowerProposition(power.name, eventName))						
			}
		}			
		
		for(Map.Entry<String, String> entry : propositions.entrySet()) {
			if(entry.value.length > 0) {
				var situationName = entry.getKey() + "_termination"
				addSituation(situationName, entry.getValue())
				situations.put(entry.getKey(), situationName + ".state=holds")			
			}
		}
		
		return situations
	}*/
	
	def String returnSituations () {
		var situations = ""
		for(situation : pcSituations) {
			situations += situation + "\n"
		}
		return situations
	}
	
	def List<PAtomPredicate> collectPropositionEvents(Proposition proposition){
		val list = new ArrayList<PAtomPredicate>
		switch (proposition){
			POr: {
				list.addAll(collectPropositionEvents(proposition.left))
				list.addAll(collectPropositionEvents(proposition.right))
			} 
			PAnd: {
				list.addAll(collectPropositionEvents(proposition.left))
				list.addAll(collectPropositionEvents(proposition.right))
			} 
			PEquality: {
				list.addAll(collectPropositionEvents(proposition.left))
				list.addAll(collectPropositionEvents(proposition.right))
			} 
			PComparison: {
				list.addAll(collectPropositionEvents(proposition.left))
				list.addAll(collectPropositionEvents(proposition.right))
			} 
			PAtomRecursive: list.addAll(collectPropositionEvents(proposition.inner))
			NegatedPAtom: list.addAll(collectPropositionEvents(proposition.negated))
			PAtomPredicate: list.add(proposition)
//			PAtomEnum:
//			PAtomVariable: 
//			PAtomPredicateTrueLiteral: 
//			PAtomPredicateFalseLiteral: 
//			PAtomIntLiteral: 
//			PAtomStringLiteral: 
		}
		return list
	}
	
	def String generatePropositionString(String normName, normType nType, propositionType pType, Proposition proposition){
		switch (proposition){
			POr: return generatePropositionString(normName, nType, pType, proposition.left) + "|" + generatePropositionString(normName, nType, pType, proposition.right) 
			PAnd: return generatePropositionString(normName, nType, pType, proposition.left) + "&" + generatePropositionString(normName, nType, pType, proposition.right) 
			PEquality: return generatePropositionString(normName, nType, pType, proposition.left) + getEqualityOperator(proposition.op) + generatePropositionString(normName, nType, pType, proposition.right) 
			PComparison: return generatePropositionString(normName, nType, pType, proposition.left) + proposition.op + generatePropositionString(normName, nType, pType, proposition.right)
			PAtomRecursive: return "(" + generatePropositionString(normName, nType, pType, proposition.inner) + ")"
			NegatedPAtom: return "!(" + generatePropositionString(normName, nType, pType, proposition.negated) + ")"
			PAtomPredicate: return generatePredicateFunctionString(normName, nType, pType, proposition.predicateFunction)
			PAtomEnum: return proposition.enumeration + "." + proposition.enumItem
			PAtomVariable: return generateDotExpressionString(proposition.variable, 'this')
			PAtomPredicateTrueLiteral: return "TRUE"
			PAtomPredicateFalseLiteral: return "FALSE" 
			PAtomDoubleLiteral: return proposition.value.toString
			PAtomIntLiteral: return proposition.value.toString
			PAtomStringLiteral: return proposition.value 
		}
	}
	
	// challenge: convert Happens(violated(obligation)) to a situation
	def String generatePredicateFunctionString(String normName, normType nType, propositionType pType, PredicateFunction predicate){		
		switch (predicate){
			PredicateFunctionHappens: switch (predicate.event) {
									VariableEvent: return '''«generateProposition(normName, nType, pType, generateEventVariableString(predicate.event))»'''
									PowerEvent: return '''«generateEventVariableString(predicate.event)»'''
									ObligationEvent: return '''«generateEventVariableString(predicate.event)»'''		
									ContractEvent: return '''«generateEventVariableString(predicate.event)»'''
								}
			PredicateFunctionHappensBefore: return '''«generateEventVariableString(predicate.event)».event._happened'''
			PredicateFunctionHappensAfter: return 'Predicate.happensAfter(e, ts)' 
			PredicateFunctionHappensWithin: return '''happensWithin(«generateEventVariableString(predicate.event)», ts)'''
		}	
	}
	
	def String getEvent(PredicateFunction predicate){
		switch (predicate){
			PredicateFunctionHappens: return '''«extractEventVariableString(predicate.event)»'''
			PredicateFunctionHappensBefore: return '''«extractEventVariableString(predicate.event)»'''
			PredicateFunctionHappensAfter: return '' 
			PredicateFunctionHappensWithin: return '''«extractEventVariableString(predicate.event)»'''
		}	
	}
	def String extractEventVariableString(Event event){
		switch (event){
			VariableEvent: return generateDotExpressionString(event.variable, '')
			PowerEvent: return '''«event.eventName.toLowerCase»'''
			ObligationEvent: return '''«event.eventName.toLowerCase»'''
			ContractEvent: return '''«event.eventName.toLowerCase»'''
		}	
	}
	
	def String eventToSituation (String event) {
		switch (event) {
			case "violated": return "violation"
			case "suspended": return "suspension"
			case "resumed": return "resumption"
			case "discharged": return "dischargment"
			case "expired": return "expirtion"
			case "fulfilled": return "fulfillment"
			case "terminated": return "termination"			
			case "revokedParty": return "unassign"				
		}
	}
	
	def String generateEventVariableString(Event event){
		switch (event){
			VariableEvent: return generateDotExpressionString(event.variable, '')
			PowerEvent: return '''«event.powerVariable.name».state=«eventToSituation(event.eventName.toLowerCase)»'''
			ObligationEvent: return '''«event.obligationVariable.name».state=«eventToSituation(event.eventName.toLowerCase)»'''			
			ContractEvent: return '''cnt.state=«eventToSituation(event.eventName.toLowerCase)»'''
		}	
	}
	
	def String eventType(Event event){
		switch (event){
			VariableEvent: return "event"
			PowerEvent: return "situation"
			ObligationEvent: return "situation" 			
			ContractEvent: return "situation"
		}
	}	
	
	def String generateExpressionString (Expression argExpression, String thisString) {
		switch (argExpression){
			Or: return generateExpressionString(argExpression.left, thisString) + " || " + generateExpressionString(argExpression.right, thisString)
			And: return generateExpressionString(argExpression.left, thisString) + " && " + generateExpressionString(argExpression.right, thisString)
			Equality: return  generateExpressionString(argExpression.left, thisString) + getEqualityOperator(argExpression.op) + generateExpressionString(argExpression.right, thisString)
			Comparison: return generateExpressionString(argExpression.left, thisString) + argExpression.op + generateExpressionString(argExpression.right, thisString)
			Plus: return generateExpressionString(argExpression.left, thisString) + " + " + generateExpressionString(argExpression.right, thisString)
			Minus: return generateExpressionString(argExpression.left, thisString) + " - " + generateExpressionString(argExpression.right, thisString)
			Multi: return generateExpressionString(argExpression.left, thisString) + " * " + generateExpressionString(argExpression.right, thisString)
			Div: return generateExpressionString(argExpression.left, thisString) + " / " + generateExpressionString(argExpression.right, thisString)
			PrimaryExpressionRecursive: return "(" + generateExpressionString(argExpression.inner, thisString) + ")"
			PrimaryExpressionFunctionCall: return generateFunctionCall(argExpression, thisString)
			NegatedPrimaryExpression: return "!(" + generateExpressionString(argExpression.expression, thisString) + ")"
			AtomicExpressionTrue: return "true"
			AtomicExpressionFalse: return "false"
			AtomicExpressionDouble: return argExpression.value.toString()
			AtomicExpressionInt: return argExpression.value.toString()
			AtomicExpressionEnum: return argExpression.enumeration + "." + argExpression.enumItem
			AtomicExpressionString: return argExpression.value
			AtomicExpressionParameter: return generateDotExpressionString(argExpression.value, thisString)
		}
	}

	def String generateDotExpressionString (Ref argRef, String thisString) {
		val ids = new ArrayList<String>()
		var ref = argRef
		while (ref instanceof VariableDotExpression){
			ids.add(ref.tail.name)
			ref = ref.ref	
		}
		if (ref instanceof VariableRef) {
			ids.add((ref as VariableRef).variable)	
		}
		if (thisString != null)
			ids.add(thisString)
		
		var revIds = ids.reverse()
		var expression = ""
		for(id : revIds)
			if(expression === ""){
				expression = id
			} else {
				expression += "." + id
			}
				
		return expression
	}
	
	def String generateFunctionCall(PrimaryExpressionFunctionCall argFunctionCallExp, String thisString) {
		val functionCall = argFunctionCallExp.function
		switch (functionCall) {
			TwoArgMathFunction: return functionCall.name + "(" + generateExpressionString(functionCall.arg1, thisString) + "," + generateExpressionString(functionCall.arg2, thisString) + ")"
			OneArgMathFunction: return functionCall.name + "(" + generateExpressionString(functionCall.arg1, thisString) + ")"
			TwoArgStringFunction: return functionCall.name + "(" + generateExpressionString(functionCall.arg1, thisString) + "," + generateExpressionString(functionCall.arg2, thisString) + ")"
			OneArgStringFunction: return functionCall.name + "(" + generateExpressionString(functionCall.arg1, thisString) + ")"
		}
	}
	
	def String getEqualityOperator(String op) { 
		switch (op) {
			case '!=': return '!=='
			case '==': return '==='
		}
	}

	def RegularType getBaseType(DomainType domainType) {
		switch (domainType) {
			RegularType:
				if (domainType.ontologyType !== null) {
					return domainType
				} else {
					return getBaseType(domainType.regularType)
				}
			default:
				null
		}
	}
	
	 // Generate generic modules
	 def String generateStaticModules () {
		val code = '''
		MODULE Timer(start)
		 VAR active1  : boolean;
		     expired1 : boolean;
		 ASSIGN
		   init(active1) := start;
		   next(active1) := (active1 | start) ? TRUE : active1;
		   init(expired1) :=  active1 ? {TRUE,FALSE} : FALSE;
		   next(expired1) :=  case
		           active1 & !expired1 : {TRUE,FALSE};
		           expired1           : TRUE;
		           TRUE              : FALSE;
		       esac;
		
		MODULE Event(start)
		 DEFINE _inactive := (state = inactive);
		        _happened := (state = happened);
		        _expired  := (state = expired);
		 VAR triggered : boolean;
		         timer : Timer(start & !_happened & !_expired);
		         state : {inactive, active, happened, expired};
				 performer	: {"CBEEF", "COSTCO"};
		
		 ASSIGN
			next(performer)	:= case
				state=active & start	: {"CBEEF", "COSTCO"};
				TRUE	 				: performer;
			esac;
		 ASSIGN
		  init(triggered) := FALSE;
		  next(triggered) := (state=active & start) ? {FALSE,TRUE} : FALSE;
		  init(state)     := inactive;
		  next(state)     := case
		    state=inactive & start                          : active;
		    state=active & start & triggered &
									timer.active1 : happened;
			state=active & start & timer.expired1 : expired;
		    TRUE                                            : state;
		  esac;
		
		--------------------------------------------------------------------------------------
		-- 'name' is party name
		-- 'removeL/R/P' releases liability, righHolder or performer position of a party
		-- 'addL/R/P' adds liability, righHolder or performer position to a party
		--------------------------------------------------------------------------------------
		MODULE Party(norm, name, removeL, addL, removeR, addR, removeP, addP)
		  DEFINE
			_name 			:= name;
			_norm			:= norm;
			_is_performer	:= p_state=P;
			_is_liable		:= l_state=L;
			_is_rightHolder	:= r_state=R;
		
		  VAR
			l_state	: {Init, L};
			r_state	: {Init, R};
			p_state	: {Init, P};
		
		  ASSIGN
			init(l_state) := Init;
			next(l_state)	:= case
				l_state=Init & addL	: L;
				l_state=L &removeL	: Init;
				TRUE				: l_state;
			esac;
		
		  ASSIGN
			init(r_state) := Init;
			next(r_state)	:= case
				r_state=Init & addR	: R;
				r_state=R & removeR : Init;
				TRUE				: r_state;
			esac;
		
		  ASSIGN
			init(p_state) := Init;
			next(p_state)	:= case
				p_state=Init & addP : P;
				p_state=P & removeP	: Init;
				TRUE				: p_state;
			esac;
		
		  INVAR
			!(addL & removeL) &
			!(addR & removeR) &
			!(addP & removeP) &
			!(_is_rightHolder & _is_liable);
		
		--------------------------------------------------------------------------------------
		-- 'cnt_in_effect'    indicates if the contract is in inEffect state
		-- 'power_suspended'  indicates if a power suspends the obligation
		-- 'cnt_suspended'    indicates if the contract suspension suspends the obligation
		-- 'power_resumed'    indicates if a power resumption resumes the obligation
		-- 'cnt_resumed'      indicates if the contract resumption resumes the obligation
		--------------------------------------------------------------------------------------
		MODULE Obligation(name, surviving, cnt_in_effect, cnt_untermination,
		                  fulfilled, triggered, violated, activated,
						  expired1, power_suspended, cnt_suspended, terminated, power_resumed,
						  cnt_resumed, discharged, antecedent)
		  DEFINE
			_name 		:= name;
			_surviving	:= surviving;
			_suspended 	:= (power_suspended | (cnt_suspended & !surviving));
			_active 	:= (state = inEffect | state = suspension);
		
		  VAR
			state 		: {not_created, create, inEffect, suspension, discharge,
						   fulfillment, violation, unsTermination};
			sus_state	: {not_suspended, sus_by_contract, sus_by_power};
		
		  ASSIGN
		 --NEW: update axioms(surviving obligations are not suspended! informally mentioned)
			init(sus_state) := not_suspended;
			next(sus_state)	:= case
				sus_state=not_suspended & !surviving & cnt_suspended 	: sus_by_contract;
				sus_state=sus_by_contract & !surviving & cnt_resumed	: not_suspended;
				sus_state=not_suspended & !surviving & power_suspended 	: sus_by_power;
				sus_state=sus_by_power & !surviving & power_resumed		: not_suspended;
				TRUE													: sus_state;
			esac;
		
		  ASSIGN
		    init(state) := not_created;
		    next(state) := case
				cnt_in_effect & state=not_created   & triggered & !antecedent : create;
				cnt_in_effect & state=not_created   & triggered & antecedent  : inEffect;
				cnt_in_effect & state=create        & antecedent              : inEffect;
				cnt_in_effect & state=create        & (expired1 | discharged)  : discharge;
				cnt_in_effect & state=inEffect      & fulfilled               : fulfillment;
				cnt_in_effect & state=inEffect      & _suspended              : suspension;
				cnt_in_effect & state=inEffect      & violated                : violation;
				cnt_in_effect & _active            	& terminated              : unsTermination;
				cnt_untermination & !surviving  	& _active           	  : unsTermination;
				sus_state=sus_by_contract & state=suspension  & cnt_resumed   : inEffect;
				sus_state=sus_by_power	  & state=suspension  & power_resumed   : inEffect;
				TRUE                                                          : state;
		  esac;
		
		--------------------------------------------------------------------------------------
		-- 'cnt_in_effect'   indicates if the contract is in inEffect state
		-- 'power_suspended' indicates if a power suspends the power
		-- 'cnt_suspended'   indicates if the contract suspension suspends the power
		-- 'power_resumed'   indicates if a power resumption resumes the power
		-- 'cnt_resumed'     indicates if the contract resumption resumes the power
		--------------------------------------------------------------------------------------
		MODULE Power(name, cnt_in_effect, triggered, activated, expired1, power_suspended, cnt_suspended,
		       	     terminated, exerted, power_resumed, cnt_resumed, antecedent)
		  DEFINE
			_name		 := name;
			_active 	 := (state = inEffect | state = suspension);
			_suspended 	 := (power_suspended | cnt_suspended);
		
		  VAR
			state 		: {not_created, create, inEffect, suspension, sTermination, unsTermination};
			sus_state	: {not_suspended, sus_by_contract, sus_by_power};
		
		  ASSIGN
			init(sus_state) := not_suspended;
			next(sus_state)	:= case
				sus_state=not_suspended & cnt_suspended 	: sus_by_contract;
				sus_state=sus_by_contract & cnt_resumed		: not_suspended;
				sus_state=not_suspended & power_suspended 	: sus_by_power;
				sus_state=sus_by_power & power_resumed		: not_suspended;
				TRUE										: sus_state;
			esac;
		
		  ASSIGN
		   init(state) := not_created;
		   next(state) := case
		     cnt_in_effect & state = not_created 	& triggered & !antecedent : create;
		     cnt_in_effect & state = not_created 	& triggered & antecedent  : inEffect;
		     cnt_in_effect & state = create      	& antecedent              : inEffect;
		     cnt_in_effect & state = create      	& expired1                : unsTermination;
		     cnt_in_effect & state = inEffect    	& exerted                 : sTermination;
		     cnt_in_effect & state = inEffect   	& _suspended              : suspension;
		     cnt_in_effect & state = inEffect    	& expired1                : unsTermination;
			 cnt_in_effect & _active  			 	& terminated              : unsTermination;
		
			 sus_state=sus_by_contract & state=suspension  & cnt_resumed 	  : inEffect;
			 sus_state=sus_by_power	   & state=suspension  & power_resumed      : inEffect;
		
		     TRUE                                          				   	  : state;
		   esac;
		
		--------------------------------------------------------------------------------------
		-- 'assigned_party'				 indicates if a party is assigned to a role
		-- 'revoked_party'				 indicates if a party is unassigned from a role
		-- 'fulfilled_active_obligation' indicates if all active obligations are fulfilled
		--------------------------------------------------------------------------------------
		MODULE Contract(triggered, activated, terminated, suspended, resumed,
						revoked_party, assigned_party, fulfilled_active_obligation)
		  DEFINE
			_active 	 := (state = unassign | state = inEffect | state = suspension);
			_termination := (state = sTermination | state = unsTermination);
		
			-- obligations/powers' status changes once the contract goes to inEffect state
			_o_activated := (state = form & activated) |
								(state = suspension & resumed) |
								(state = unassign & assigned_party) |
								(state = inEffect);
		
		  VAR
			state 		 : { not_created, form, inEffect, suspension, unassign, sTermination, unsTermination};
		
		  ASSIGN
		    init(state) := not_created;
		    next(state) := case
				state = not_created & triggered  					: form;
				state = form        & activated  					: inEffect;
				state = inEffect    & fulfilled_active_obligation  	: sTermination;
				state = inEffect    & suspended  					: suspension;
				state = inEffect    & revoked_party  				: unassign;
				state = inEffect    & terminated 					: unsTermination;
				state = suspension  & resumed    					: inEffect;
				state = suspension  & terminated 					: unsTermination;
				state = unassign    & assigned_party 				: inEffect;
				state = unassign    & terminated 					: unsTermination;
				TRUE                             					: state;
		    esac;
		
		--------------------------------------------------------------------------------------
		-- Domain Concepts
		--------------------------------------------------------------------------------------
		MODULE Role(party)
		 DEFINE
			_party := party;
		
		MODULE Asset(owner)
			DEFINE _owner := owner;
		 
		MODULE Situation(proposition)
		 VAR state: {holds, not_holds};
		 ASSIGN
		    init(state) := not_holds;
		    next(state) := case
				state = not_holds & proposition : holds;
				state = holds & !proposition 	: not_holds;
				TRUE 							: state;
			esac;
			
		MODULE HappensWithin(event, situation)
		 VAR state: {happened, not_happened};
		 ASSIGN
		    init(state) := not_happened;
		    next(state) := case
				event.state = active & next(evnet.state) = happened & state = not_happened & situation.state = hold : happened;
				TRUE : state;
			esac;
		'''
		return code
	}

	/**
	 * Generate domain modules
	 */
	def void generateEnumeration(IFileSystemAccess2 fsa, Enumeration enumeration) {
		val code = '''	
			MOSULE «enumeration.name» (inValue)
				CONSTANTS
			  	«FOR item : enumeration.enumerationItems»
			  		«IF enumeration.enumerationItems.indexOf(item) == enumeration.enumerationItems.size()-1 »
			  			"«item.name»"
			  		«ELSE»
			  			"«item.name»",
			  		«ENDIF»
			  	«ENDFOR»;			
			DEFINE	
				value := inValue;
		'''
		pcEnumerations.add(code)
	}

	def void generateEvent(IFileSystemAccess2 fsa, RegularType event) {
		val isBase = event.ontologyType !== null

		if (isBase === true) {
			val code = '''
				«IF event.attributes.size()>0»
					MODULE «event.name»(start, «event.attributes.map[Attribute a | a.name].join(',')»)
						DEFINE
							«FOR attribute : event.attributes»
								_«attribute.name» := «attribute.name»;
							«ENDFOR»
				«ELSE»
					MODULE «event.name»(start)
				«ENDIF»					
					VAR
						event : Event(start);
			'''
			pcDomEvents.add(code)
		} else if (event.regularType !== null) {
			val parentType = event.regularType
			val allAttributes = Helpers.getAttributesOfRegularType(event)
			val parentAttributes = new ArrayList<Attribute>(allAttributes)
			parentAttributes.removeAll(event.attributes)
			val code = '''
				«IF allAttributes.size()>0»
					MODULE «event.name»(start, «allAttributes.map[Attribute a | a.name].join(',')»)
						DEFINE
							«FOR attribute : event.attributes»
								_«attribute.name» := «attribute.name»;
							«ENDFOR»
				«ELSE»
					MODULE «event.name»(start)
				«ENDIF»
					VAR
						event : «parentType.name»(start, «parentAttributes.map[Attribute a | a.name].join(',')»);
			'''
			pcDomEvents.add(code)
		}
	}

	def void generateRole(IFileSystemAccess2 fsa, RegularType role) {
		val isBase = role.ontologyType !== null

		if (isBase === true) {
			val code = '''
				«IF role.attributes.map[Attribute a | a.name].length > 0»
					MODULE «role.name»(party, «role.attributes.map[Attribute a | a.name].join(',')»)
				«ELSE»
					MODULE «role.name»(party)
				«ENDIF»
					DEFINE
						«FOR attribute : role.attributes»
							_«attribute.name» := «attribute.name»;
						«ENDFOR»
					VAR
						role : Role(party);
			'''
			pcRoles.add(code)
		} else if (role.regularType !== null) {
			val parentType = role.regularType
			val allAttributes = Helpers.getAttributesOfRegularType(role)
			val parentAttributes = new ArrayList<Attribute>(allAttributes)
			parentAttributes.removeAll(role.attributes)
			val code = '''
				«IF allAttributes.map[Attribute a | a.name].length > 0»
					MODULE «role.name»(party, «allAttributes.map[Attribute a | a.name].join(',')»)
				«ELSE»
					MODULE «role.name»(party)
				«ENDIF»
					DEFINE
						«FOR attribute : role.attributes»
							_«attribute.name» := «attribute.name»;
						«ENDFOR»
					VAR
						role : «parentType.name»(party, «parentAttributes.map[Attribute a | a.name].join(',')»);
			'''
			pcRoles.add(code)
		}
	}
	
	def String generateDomainModules () {
		val code = '''
		«FOR penum : pcEnumerations»
		«penum»
		
		«ENDFOR»
		
		«FOR role : pcRoles»
		«role»
		
		«ENDFOR»
		
		«FOR asset : pcAssets»
		«asset»
		
		«ENDFOR»
		
		«FOR event : pcDomEvents»
		«event»
		
		«ENDFOR»
		'''
		return code
	}
	
	def String generateConstrants() {
		val norms= new ArrayList<String>
		for(obligation : obligations) 
			norms.add('"' + obligation.name + '"')

		for(power : powers)
			norms.add('"' + power.name + '"')
		
		return String.join(", ", norms) + ';';
	}
	
	// challenge: difficult to map attributes and parties, written in parameters, to roles
	def String generateRoleInstances() {
		val code = '''
		«FOR Map.Entry<String, Pair<String, String>> entry : roleInstances.entrySet()»
		«entry.key» : «entry.value.key»(«entry.value.value»);
		«ENDFOR»
		'''
		return code
	}
	
	def String generateContractParameters(Model model) {
	}
	
	/**
	 * Description: convert Symboleo’s contract concept to SymboleoPC’s module
	 * Principle: 2
	 */
	def void compileContract(IFileSystemAccess2 fsa, Model model) {
		var cntTermination = generateContractTerminationSituation(model);
		var cntSuspension = generateContractSuspensionSituation(model);
		var cntResumption = generateContractResumptionSituation(model);
		
		var oblsTermination = generateObligationsTerminationSituation(model);
		var oblsSuspension = generateObligationsSuspensionSituation(model);
		var oblsResumption = generateObligationsResumptionSituation(model);
		var oblsDiscard = generateObligationsDischargeSituation(model);
		var oblsViolated = generateObligationViolatedSituation(model);
		var oblsExpired = generateObligationExpiredSituation(model);		
		
		var powsExpired = generatePowerExpiredSituation(model);
		var powsExerted = generatePowerExertedSituation(model);
		
		var antecedents = generateAntecedentsSituation(model);
		var consequents = generateConsequentsSituation(model);
		var triggers = generateTriggersSituation(model);
		
		val code = '''
		«generateStaticModules()»
		«generateDomainModules()»
		
		MODULE «model.contractName» («pcParameters.join(', ')»)
		
			CONSTANTS
			«generateConstrants()»
			
			VAR
				«compileDeclarationVariables(model)»
				
				cnt_succ_Termination : Situation((cnt.state=inEffect)
				«FOR obligation: obligations» 
				& !(«obligation.name»._active)
				«ENDFOR»
				);
				
				«returnSituations()»
				
				cnt: Contract(TRUE, TRUE, «cntTermination», «cntSuspension», «cntResumption», FALSE, FALSE, cnt_succ_Termination.state=holds);
								
				
				«FOR obligation: obligations»
				«val antecedent = antecedents.get(obligation.name)»
				«val consequent = consequents.get(obligation.name)»
				«val trigger = triggers.get(obligation.name)»
				«val oblTerm = oblsTermination.get(obligation.name) !== null ? oblsTermination.get(obligation.name) : "FALSE"»
				«val oblSus = oblsSuspension.get(obligation.name) !== null ? oblsSuspension.get(obligation.name) : "FALSE"»
				«val oblRes = oblsResumption.get(obligation.name) !== null ? oblsResumption.get(obligation.name) : "FALSE"»
				«val oblDisc = oblsDiscard.get(obligation.name) !== null ? oblsDiscard.get(obligation.name) : "FALSE"»
				«val oblViol = oblsViolated.get(obligation.name) !== null ? oblsViolated.get(obligation.name) : "FALSE"»
				«val oblExp = oblsExpired.get(obligation.name) !== null ? oblsExpired.get(obligation.name) : "FALSE"»
				«val oblAct = "FALSE"»
				«val oblName = obligation.name»
				
				«oblName» : Obligation("«oblName»", FALSE, cnt._o_activated, «cntTermination», «consequent», «trigger», «oblViol», «oblAct», «oblExp», «oblSus», «cntSuspension», «oblTerm», «oblRes», «cntResumption», «oblDisc», «antecedent»);		
				«ENDFOR»
				
				«FOR power: powers»
				«val antecedent = antecedents.get(power.name)»
				«val trigger = triggers.get(power.name)»
				«val powAct = "FALSE"»
				«val powSus = "FALSE"»
				«val powTerm = "FALSE"»
				«val powRes = "FALSE"»
				«val powName = power.name»
				«val powExe = powsExerted.get(power.name) !== null ? powsExerted.get(power.name) : "FALSE"»
				«val powExp = powsExpired.get(power.name) !== null ? powsExpired.get(power.name) : "FALSE"»
				
				«power.name» : Power("«powName»", cnt._o_activated, «trigger», «powAct», «powExp», «powSus», «cntSuspension», «powTerm», «powExe», «powRes», «cntResumption», «antecedent»);
				«ENDFOR»
				
				«compileParties()»
		'''
		fsa.generateFile("./domain/contracts/" + model.contractName + ".smv", code)
	}
	
	def void compileDomainTypes(IFileSystemAccess2 fsa, List<DomainType> domainTypes) {
		for (asset : assets) {
			generateAsset(fsa, asset)
		}
		for (event : events) {
			generateEvent(fsa, event)
		}
		for (role : roles) {
			generateRole(fsa, role)
		}

		// should update
		for (enumeration : enumerations) {
			generateEnumeration(fsa, enumeration)
		}
	}
	
	def void generateAsset(IFileSystemAccess2 fsa, RegularType asset) {
		val isBase = asset.ontologyType !== null

		// challenge: add owner as a keyword and a default attribute of assets
		if (isBase === true) {
			val code = '''
				MODULE «asset.name» («asset.attributes.map[Attribute a | a.name].join(',')»)
				«IF asset.attributes.size()>0»
					DEFINE 
						«FOR attribute : asset.attributes»
							_«attribute.name» := «attribute.name»;
						«ENDFOR»
				«ENDIF»				
				VAR
					asset:Asset(owner);
			'''
			pcAssets.add(code)
		} else if (asset.regularType !== null) {
			val parentType = asset.regularType
			val allAttributes = Helpers.getAttributesOfRegularType(asset)
			val parentAttributes = new ArrayList<Attribute>(allAttributes)
			parentAttributes.removeAll(asset.attributes)
			
			
			val code = '''
				MODULE «asset.name» («asset.attributes.map[Attribute a | a.name].join(',')»)
				«IF asset.attributes.size()>0»
					DEFINE 
						«FOR attribute : asset.attributes»
							_.«attribute.name» = «attribute.name»;
						«ENDFOR»
				«ENDIF»
				VAR
					asset:«parentType.name»(«parentAttributes.map[Attribute a | a.name].join(',')»);		
			'''
			pcAssets.add(code)
		}
	}
	
	def String generateEventInitSituation (Model model, String eventName) {
		var List<String> situations = new ArrayList<String>()
		var String situation = "";
			
		for(obligation: model.obligations) {
			var propositions = obligationAntecedentEvents.get(obligation)
			if(propositions !== null)
				for(p : propositions) {				
					var ev = getEvent(p.predicateFunction)
					if(ev.equals(eventName)){
						situations.add(obligation.name + ".state=create")					
					}
				}	
			
			propositions = obligationConsequentEvents.get(obligation)
			if(propositions !== null)
				for(p : propositions) {
					var ev = getEvent(p.predicateFunction)
					if(ev.equals(eventName)){
						situations.add(obligation.name + ".state=inEffect")
					}	
				}	
			
			propositions = obligationTriggerEvents.get(obligation)
			if(propositions !== null)
				for(p : propositions) {
					var ev = getEvent(p.predicateFunction)
					if(ev.equals(eventName)){
						situations.add("cnt.state=inEffect")
					}
				}		
		}
		
		for(power: model.powers) {
			var propositions = powerAntecedentEvents.get(power)
			if(propositions !== null)
				for(p : propositions) {				
					var ev = getEvent(p.predicateFunction)
					if(ev.equals(eventName)){
						situations.add(power.name + ".state=create")					
					}
				}	
			
			propositions = powerTriggerEvents.get(power)
			if(propositions !== null)
				for(p : propositions) {
					var ev = getEvent(p.predicateFunction)
					if(ev.equals(eventName)){
						situations.add("cnt.state=inEffect")
					}
				}		
		}
			
		for(s : situations) {
			if(situation === ""){
				situation = s;
			}
			else{
				situation += " | " + s;
			}
		}

		return situation
	}
	
	def void addDeclarationVariables (Model model) {	
		// challenge: assume that attributes are on the same order as definition
		for(variable: model.variables) {		
			var situation = generateEventInitSituation(model, variable.name);
			var assgs = new ArrayList<String>
			
			if(variable.type instanceof RegularType)
				for(assignment: variable.attributes)
					if(assignment instanceof AssignVariable)
						assgs.add(generateDotExpressionString(assignment.value, null))
					else if(assignment instanceof AssignExpression)
						assgs.add(generateExpressionString(assignment.value, null))

			var String attributes = ""
			for(item : assgs) {
				if(attributes.length === 0 && situation.length === 0)
					attributes += item
				else
					attributes += ',' + item
			}
			
			addVariable(variable.name, situation, variable.type.name, attributes)
		}
	}
	
	def String compileDeclarationVariables(Model model) {
		addDeclarationVariables(model)
		
		val code = '''
			«FOR variable : pcVariables»			
				«variable.getValue()»
			«ENDFOR»
			'''
		return code;
	}
	
	def String compileConstraints() {
		
		/*for (const : constraints) {
			val code = '''
			«generatePropositionString(const)»
			'''
			return code;
		}*/
	}
	
	def String compileParties() {
		val code = '''
		«FOR obligation:obligations»
			«obligation.name»_debtor : Party(«obligation.name»._name, «generateDotExpressionString(obligation.debtor, '')».role._party, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE);
			«obligation.name»_creditor : Party(«obligation.name»._name, «generateDotExpressionString(obligation.creditor, '')».role._party, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE);
		«ENDFOR»
		
		«FOR power:powers»
			«power.name»_debtor : Party(«power.name»._name, «generateDotExpressionString(power.debtor, '')».role._party, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE);
			«power.name»_creditor : Party(«power.name»._name, «generateDotExpressionString(power.creditor, '')».role._party, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE);
		«ENDFOR»
		'''
		return code
	}
	
	
	def void generatePCSource(IFileSystemAccess2 fsa, Model model) {
		parse(model)
		compileDomainTypes(fsa, model.domainTypes)
		compileContract(fsa, model)
	}
	
	def void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (e : resource.allContents.toIterable.filter(Model)) {
			generatePCSource(fsa, e)
		}
	}
}